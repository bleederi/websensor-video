<!--
Copyright 2017 Jesse Nieminen

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<!doctype html>
<html>
	<head>
                <meta charset="UTF-8" />
                <meta name="viewport" content="width=device-width, initial-scale=0.6">
                <link rel="manifest" href="manifest.json" />
		<style>
			body{
				margin: 0;
			}
		</style>
		
	</head>
        <template id="video-view">
                <style>
                :host {
                width: 100vh;
                height: 100vh;
                }
                </style>
        </template>
	<body>
                <button onclick="playPause()">Play/Pause</button>
                <button onclick="rewind()">Rewind</button>
                <video-view>
                        <video id="video1" width="800" height="600" autoplay>
                        <source src="video.mp4" type="video/mp4">
                        Your browser does not support the video tag.
                        </video>
                </video-view>
                <script type="text/javascript" src="script.js"></script>        <!-- Contains the step detection algorithm -->
                <script>
		//TODO: fix rewind by using two video streams, one forward and one backward
                var myVideo = document.getElementById("video1"); 
                var rewinding = false;
                var rw; //variable for controlling the rewind loop
                var fps = 30;
                var accelerationData = [];        //sequence to store xyz accelerometer readings
                var accelSeq = {x:null, y:null, z:null};      //dict to store accelerometer reading sequences 
                var accel = {x:null, y:null, z:null};
                var prevaccel = {x:null, y:null, z:null};
                var diff = {x:null, y:null, z:null};
                var stepvar = 0;
                var sensorfreq = 60;
                var amtStepValues = 2*sensorfreq; //setting buffer size for step analysis (how many values will be inspected) - should be about how long 2 steps will take (here 1 second * 2 = 2 seconds)
                var reading;    //variable for controlling the data reading loop
                var derseq;
                var derseq_old;
                var maseq;
                var maseq_old;
                myVideo.pause();
                        class Pedometer {
                                constructor() {
                                const sensor = new Accelerometer({ frequency: sensorfreq });
                                sensor.onchange = () => {
                                        accel = {'x':sensor.x, 'y':sensor.y, 'z':sensor.z};
                                        if (this.onchange) this.onchange();
                                };
                                sensor.onactivate = () => {
                                        if (this.onactivate) this.onactivate();
                                }
                                const start = () => sensor.start();
                                Object.assign(this, { start });
                                }
                        }
                        class KalmanFilter {    //Kalman filter implementation from websensor-compass
                          constructor() {
                            this.Q_angle = 0.01;
                            this.Q_gyro = 0.0003;
                            this.R_angle = 0.01;

                            this.reset();
                          }

                          reset() {
                            this.angle = 0.0;
                            this.bias = 0;

                            this.P00 = 0;
                            this.P01 = 0;
                            this.P10 = 0;
                            this.P11 = 0;
                          }

                          filter(accAngle, gyroRate, dt) {
                            this.angle += dt * (gyroRate - this.bias);

                            this.P00 += -dt * (this.P10 + this.P01) + this.Q_angle * dt;
                            this.P01 += -dt * this.P11;
                            this.P10 += -dt * this.P11;
                            this.P11 += + this.Q_gyro * dt;

                            let axis = accAngle - this.angle;
                            let S = this.P00 + this.R_angle;
                            let K0 = this.P00 / S;
                            let K1 = this.P10 / S;

                            this.angle += K0 * axis;
                            this.bias  += K1 * axis;

                            this.P00 -= K0 * this.P00;
                            this.P01 -= K0 * this.P01;
                            this.P10 -= K1 * this.P00;
                            this.P11 -= K1 * this.P01;

                            return this.angle;
                          }
                        };
/*      How to use:  
      // Kalman filter
          this.alpha = this.kalmanZ.filter(zAccel, zGyro, dt);
          this.beta = this.kalmanX.filter(xAccel, xGyro, dt);
          this.gamma = this.kalmanY.filter(yAccel, yGyro, dt);
*/

                        customElements.define('video-view', class extends HTMLElement {
                                constructor() {
                                super();
			        }

                                connectedCallback() {
                                        const sensor = new Pedometer();
                                        sensor.onchange = () => {                                       
                                        }
                                        sensor.onactivate = () => reading = setInterval(saveSensorReading, 1000/sensorfreq);     //start saving data from sensors in loop
                                        sensor.start();
                                        render = setInterval(render, 1000/(fps+sensorfreq));
                                }
                        });
                        function saveSensorReading()
                        {
                                accelerationData.push(accel);
                                accelSeq = toCoordSeq(accelerationData);
                                if(accelSeq['x'].length > amtStepValues && accelSeq['y'].length > amtStepValues && accelSeq['z'].length > amtStepValues)
                                {
                                        let length = accelSeq['x'].length;
                                        maseq_old = maseq;
                                        let stepvar2 = stepDetection(slice(accelSeq, length-amtStepValues, length));
                                        corr = {'x': pcorr(maseq['x'], maseq_old['x']), 'y': pcorr(maseq['y'], maseq_old['y']), 'z':pcorr(maseq['z'], maseq_old['z'])};
                                        console.log(corr['x']);
                                        if(corr['x'] <= 0.95 && corr['x'] >= 0.5)
                                        {
                                                stepvar = 1;
                                        }
                                        else
                                        {
                                                stepvar = 0;
                                        }
                                        if (stepvar == 1)
                                        {
                                                //clear buffer
                                                for (var k in accelSeq) delete accelSeq[k];
                                                accelerationData = [];
                                                //stepvar = 0;
                                        }
                                }
                        }
                        function render()
                        {
                                if(stepvar == 1)
                                {
                                        //console.log("Playing");
                                        myVideo.play(); 
                                }
                                else
                                {
                                        //console.log("Not playing");
                                        myVideo.pause(); 
                                }
		        }

                        function playPause() {
                        if (myVideo.paused)
                                myVideo.play(); 
                        else 
                                myVideo.pause(); 
                        } 	

                        function rewind() {
                                if (rewinding)
                                {
	                                rewinding = false;
	                                clearInterval(rw);
                                }
                                else
                                {
	                                rewinding = true;
	                                rw = setInterval(function(){ myVideo.currentTime = myVideo.currentTime - 1/fps; }, 1000/fps);
                                        //myVideo.setAttribute('src', 'video_backwards.mp4');
                                }
                        }			
		</script>
	</body>
</html>

