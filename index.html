<!--
Copyright 2017 Jesse Nieminen

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<!doctype html>
<html>
	<head>
                <meta charset="UTF-8" />
                <meta name="viewport" content="width=device-width, initial-scale=0.6">
                <link rel="manifest" href="manifest.json" />
		<style>
			body{
				margin: 0;
			}
		</style>
		
	</head>
        <template id="video-view">
                <style>
                :host {
                width: 100vh;
                height: 100vh;
                }
                </style>
        </template>
	<body>
                <button onclick="playPause()">Play/Pause</button>
                <button onclick="rewind()">Rewind</button>
                <video-view>
                        <video id="video1" width="800" height="600" autoplay>
                        <source src="video.mp4" type="video/mp4">
                        Your browser does not support the video tag.
                        </video>
                </video-view>
                <script type="text/javascript" src="script.js"></script>        <!-- Contains the step detection algorithm -->

                <input id="slider" type="range" min="0.1" max="2" step="0.1" value="1">

                <div id="sliderAmount"></div>
                <script>
		//TODO: fix rewind by using two video streams, one forward and one backward
                var myVideo = document.getElementById("video1"); 
                var rewinding = false;
                var rw; //variable for controlling the rewind loop
                var fps = 30;
                var accelerationData = [];        //sequence to store xyz accelerometer readings
                var accelSeq = {x:null, y:null, z:null};      //dict to store accelerometer reading sequences 
                var accel = {x:null, y:null, z:null};
                var gravity;
                var accelNoG;
                var prevaccel = {x:null, y:null, z:null};
                var diff = {x:null, y:null, z:null};
                var sensorfreq = 30;
                var stepvar = null;
                var stepamt = 4;
                var amtStepValues = stepamt*sensorfreq; //setting buffer size for step analysis (how many values will be inspected) - should be about how long 2 steps will take (here stepamt seconds)
                var reading;    //variable for controlling the data reading loop
                var derseq;
                var derseq_old;
                var maseq = null;
                var maseq_old = null;
                var lastpeakmag = null;
                var lastvalleymag = null;
                var lastpeaktime = null;
                var lastvalleytime = null;
                var stepaverage = null;
                var peaktimethreshold = null;
                var valleytimethreshold = null;
                var sensori = null;
                var discardedsamples = 0;
                var stddevthreshhold = 1;
                var slide = document.getElementById('slider'),
                sliderDiv = document.getElementById("sliderAmount");
                slide.onchange = function() {
                        sliderDiv.innerHTML = this.value;       //show the threshhold
                        stddevthreshhold = this.value;
                }â€‹
                myVideo.pause();
                        class Pedometer {
                                constructor() {
                                const sensor = new Accelerometer({ frequency: sensorfreq });
                                gravity =  new LowPassFilterData(sensor, 0.8);
                                sensor.onchange = () => {
                                        accel = {'x':sensor.x, 'y':sensor.y, 'z':sensor.z};
                                        //gravity.update(accel);
                                        if (this.onchange) this.onchange();
                                };
                                sensor.onactivate = () => {
                                        if (this.onactivate) this.onactivate();
                                }
                                const start = () => sensor.start();
                                Object.assign(this, { start });
                                }
                        }
                        class LowPassFilterData {       //https://w3c.github.io/motion-sensors/#pass-filters
                          constructor(reading, bias) {
                            Object.assign(this, { x: reading.x, y: reading.y, z: reading.z });
                            this.bias = bias;
                          }
                                update(reading) {
                                        this.x = this.x * this.bias + reading.x * (1 - this.bias);
                                        this.y = this.y * this.bias + reading.y * (1 - this.bias);
                                        this.z = this.z * this.bias + reading.z * (1 - this.bias);
                                }
                        };
                        class KalmanFilter {    //Kalman filter implementation from websensor-compass
                          constructor() {
                            this.Q_angle = 0.01;
                            this.Q_gyro = 0.0003;
                            this.R_angle = 0.01;

                            this.reset();
                          }

                          reset() {
                            this.angle = 0.0;
                            this.bias = 0;

                            this.P00 = 0;
                            this.P01 = 0;
                            this.P10 = 0;
                            this.P11 = 0;
                          }

                          filter(accAngle, gyroRate, dt) {
                            this.angle += dt * (gyroRate - this.bias);

                            this.P00 += -dt * (this.P10 + this.P01) + this.Q_angle * dt;
                            this.P01 += -dt * this.P11;
                            this.P10 += -dt * this.P11;
                            this.P11 += + this.Q_gyro * dt;

                            let axis = accAngle - this.angle;
                            let S = this.P00 + this.R_angle;
                            let K0 = this.P00 / S;
                            let K1 = this.P10 / S;

                            this.angle += K0 * axis;
                            this.bias  += K1 * axis;

                            this.P00 -= K0 * this.P00;
                            this.P01 -= K0 * this.P01;
                            this.P10 -= K1 * this.P00;
                            this.P11 -= K1 * this.P01;

                            return this.angle;
                          }
                        };
/*      How to use:  
      // Kalman filter
          this.alpha = this.kalmanZ.filter(zAccel, zGyro, dt);
          this.beta = this.kalmanX.filter(xAccel, xGyro, dt);
          this.gamma = this.kalmanY.filter(yAccel, yGyro, dt);
*/

                        customElements.define('video-view', class extends HTMLElement {
                                constructor() {
                                super();
			        }

                                connectedCallback() {
                                        sensori = new Pedometer();
                                        sensori.onchange = () => { saveSensorReading(); 
                                        //sensor.onchange = () => {                                                                
                                        }
                                        //sensor.onactivate = () => reading = setInterval(saveSensorReading, 1000/sensorfreq);     //start saving data from sensors in loop
                                        sensori.onactivate = () => {}
                                        sensori.start();
                                        reading = setInterval(saveSensorReading, 1000/sensorfreq);     //start saving data from sensors in loop
                                        render = setInterval(render, 1000/(fps+sensorfreq));
                                }
                        });
                        function saveSensorReading()
                        {
                                accel = {x:accel.x, y:accel.y, z:accel.z};
                                //accelNoG = {x:accel.x - gravity.x, y:accel.y - gravity.y, z:accel.z - gravity.z};
                                //console.log("Mags:", magnitude(prevaccel), magnitude(accel))
                                if(magnitude(prevaccel) != magnitude(accel))                               
                                {
                                        accelerationData.push(accel);
                                        prevaccel = accel;
                                        discardedsamples = discardedsamples - 5;
                                }
                                else
                                {
                                        discardedsamples = discardedsamples + 1;
                                }
                                //console.log(accelerationData);
                                accData2 = [];
                                accel2 = {x:null, y:null, z:null}
                                if(accelerationData.length >= amtStepValues)    //when we have enough data, decide whether the user is walking or not
                                {
                                        accelSeq = toCoordSeq(accelerationData);
                                        var as = Object.assign({}, accelSeq);
                                        peakdiff = [];
                                        valleydiff = [];
                                        //console.log(accelSeq);
                                        //let length = accelSeq['x'].length;
                                        //maseq_old = maseq;
                                        //let stepvar2 = stepDetection(slice(accelSeq, length-amtStepValues, length));
                                        stepvar = stepDetection(as);
                                        //console.log(maseq);                                     
                                        if(stepvar == true)
                                        {
                                                console.log("Walking");                                        
                                        }
                                        else
                                        {
                                                console.log("Not walking");
                                        }
/*
                                        corr = {'x': pcorr(maseq['x'], maseq_old['x']), 'y': pcorr(maseq['y'], maseq_old['y']), 'z':pcorr(maseq['z'], maseq_old['z'])};
                                        //console.log(corr);
                                        //console.log(magnitude(corr));
                                        if(magnitude(corr) <= 1.7 && magnitude(corr) >= 0.5 && corr['y'] >= 0)
                                        {
                                                stepvar = 1;
                                        }
                                        else
                                        {
                                                stepvar = 0;
                                        }
*/
                                        //clear buffer
                                        for (var k in accelSeq) delete accelSeq[k];
                                        //maybe try slicing?
                                        accelerationData.splice(0);
                                        lastpeakmag = null;
                                        lastvalleymag = null;
                                        lastpeaktime = null;
                                        lastvalleytime = null;
                                        stepaverage = null;
                                        peaktimethreshold = null;
                                        valleytimethreshold = null;
                                        discardedsamples = 0;
                                        //console.log(accelerationData);
                                }
                                if(discardedsamples >= amtStepValues/3)     //device most likely stationary
                                {
                                        stepvar = 0;
                                        console.log("Stationary, not walking");
                                        discardedsamples = 0;
                                }
                        }
                        function render()
                        {
                                if(stepvar == 1)
                                {
                                        //console.log("Playing");
                                        myVideo.play(); 
                                }
                                else
                                {
                                        //console.log("Not playing");
                                        myVideo.pause(); 
                                }
		        }

                        function playPause() {
                        if (myVideo.paused)
                                myVideo.play(); 
                        else 
                                myVideo.pause(); 
                        } 	

                        function rewind() {
                                if (rewinding)
                                {
	                                rewinding = false;
	                                clearInterval(rw);
                                }
                                else
                                {
	                                rewinding = true;
	                                rw = setInterval(function(){ myVideo.currentTime = myVideo.currentTime - 1/fps; }, 1000/fps);
                                        //myVideo.setAttribute('src', 'video_backwards.mp4');
                                }
                        }			
		</script>
	</body>
</html>

