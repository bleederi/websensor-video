<!--
Copyright 2017 Jesse Nieminen

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<!doctype html>
<html>
	<head>
                <meta charset="UTF-8" />
                <meta name="viewport" content="width=device-width, initial-scale=0.6">
                <link rel="manifest" href="manifest.json" />
		<style>
			body{
				margin: 0;
			}
                   #startbutton {
                        background-color: red;
                        color: #FFFFFF;
                        padding: 15px 32px;
                        border-radius: 10px;
                        margin:10px
                    }
		</style>
		
	</head>
        <template id="video-view">
                <style>
                :host {
                width: 100vh;
                height: 100vh;
                }
                </style>
        </template>
	<body>
                <button id="startbutton" onclick="startDemo()">Start demo</button>
                <button onclick="rewind()">Rewind</button>
                <video-view>
                        <video id="video1" width="1920" height="1080" crossorigin="anonymous">
                        <source src="https://raw.githubusercontent.com/jessenie-intel/websensor-video/master/forward2.mp4" type="video/mp4">
                        Your browser does not support the video tag.
                        </video>
                </video-view>
                <script type="text/javascript" src="script.js"></script>        <!-- Contains the step detection algorithm -->
                <script src="three.min.js"></script>

                <input id="slider_stddev" type="range" min="0.1" max="6" step="0.2" value="2">

                Standard deviation threshold: <div id="slider_stddev_amount"></div>

                <input id="slider_stepamt" type="range" min="1" max="5" step="0.5" value="2.5">

                Seconds to capture(delay): <div id="slider_stepamt_amount"></div>

                <input id="slider_bias" type="range" min="0.1" max="1" step="0.1" value="0.9">

                Filter bias: <div id="slider_bias_amount"></div>

                Walking status: <div id="walking_status"></div>

                Standard deviation pct: <div id="stddev"></div>

                <script>
		//TODO: fix rewind by using two video streams, one forward and one backward
                var myVideo = document.getElementById("video1"); 
                var rewinding = false;
                var rw; //variable for controlling the rewind loop
                var fps = 30;
                var accelerationData = [];        //sequence to store xyz accelerometer readings
                var accelSeq = {x:null, y:null, z:null};      //dict to store accelerometer reading sequences 
                var accel = {x:null, y:null, z:null};   //here we store sensor readings
                var accelFiltered = {x:null, y:null, z:null};
                var orientationMat = new Float64Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]);     //device orientation
                var orientationMatInitial = new Float64Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]);          //variable for storing initial orientation matrix
                var prevaccel = {x:null, y:null, z:null};
                var diff = {x:null, y:null, z:null};
                var sensorfreq = 60;
                var stepvar = null;
                var stepamt = 2;      //2.5 seems to work well for walking in place, 2 with tablet
                var amtStepValues = stepamt*sensorfreq; //setting buffer size for step analysis (how many values will be inspected) - should be about how long 2 steps will take (here stepamt seconds)
                var reading;    //variable for controlling the data reading loop
                var derseq;
                var derseq_old;
                var maseq = null;
                var maseq_old = null;
                var lastpeakmag = null;
                var lastvalleymag = null;
                var lastpeaktime = null;
                var lastvalleytime = null;
                var stepaverage = null;
                var peaktimethreshold = null;
                var valleytimethreshold = null;
                var accel_sensor = null;
                var orientation_sensor = null;
                var discardedsamples = 0;
                //In below arrays, first values for Windows tablet, second values for Nexus tablet
                var stddevthreshold = 2.9;      //0.4 good for walking in place, 2.9 with tablet
                var peakvalleyamtthreshold = [2, 6];
                var bias = 1; //bias for low-pass filtering the data, 1 seems to work good with the tablet
                var initialoriobtained = false;
                var longitude = 0;
                var latitude = 0;
                var longitudeInitial = null;
                var anglesCurrent = [];            
                var latitude;
                var longitude;
                var videocanvasctx = null;

                myVideo.pause();
                //Sliders
                var slider_stddev = document.getElementById('slider_stddev'),
                slider_stddev_div = document.getElementById("slider_stddev_amount");
                slider_stddev.onchange = () => {
                        stddevthreshold = slider_stddev.value;
                        slider_stddev_div.innerHTML = stddevthreshold;
                        console.log("Std dev threshold:", stddevthreshold);
                }
                var slider_stepamt = document.getElementById('slider_stepamt'),
                slider_stepamt_div = document.getElementById("slider_stepamt_amount");
                slider_stepamt.onchange = () => {
                        stepamt = slider_stepamt.value;
                        amtStepValues = stepamt*sensorfreq;     //recalculate
                        slider_stepamt_div.innerHTML = stepamt;
                        console.log("Step amount:", stepamt);
                }
                var slider_bias = document.getElementById('slider_bias'),
                slider_bias_div = document.getElementById("slider_bias_amount");
                slider_bias.onchange = () => {
                        bias = slider_bias.value;
                        slider_bias_div.innerHTML = bias;
                        console.log("Filter bias:", bias);
                }
                        class Pedometer {
                                constructor() {
                                const sensor = new Accelerometer({ frequency: sensorfreq });
                                sensor.onchange = () => {
                                        accel = {'x':sensor.x, 'y':sensor.y, 'z':sensor.z};
                                        if (this.onchange) this.onchange();
                                };
                                sensor.onactivate = () => {
                                        if (this.onactivate) this.onactivate();
                                }
                                const start = () => sensor.start();
                                Object.assign(this, { start });
                                }
                        }
                        class AbsOriSensor {
                                constructor() {
                                const sensor = new AbsoluteOrientationSensor({ frequency: sensorfreq });
                                const mat4 = new Float32Array(16);
                                const euler = new Float32Array(3);
                                sensor.onchange = () => {
                                        sensor.populateMatrix(mat4);
                                        let angles = toEulerianAngle(sensor.quaternion, euler);
                                        //console.log("ANGLES:", angles);
                                        this.roll = euler[0];
                                        this.pitch = euler[1];
                                        this.yaw = euler[2];
                                        if (this.onchange) this.onchange();
                                };
                                sensor.onactivate = () => {
                                        if (this.onactivate) this.onactivate();
                                }
                                const start = () => sensor.start();
                                Object.assign(this, { start });
                                }
                        }
                        class LowPassFilterData {       //https://w3c.github.io/motion-sensors/#pass-filters
                          constructor(reading, bias) {
                            Object.assign(this, { x: reading.x, y: reading.y, z: reading.z });
                            this.bias = bias;
                          }
                                update(reading) {
                                        this.x = this.x * this.bias + reading.x * (1 - this.bias);
                                        this.y = this.y * this.bias + reading.y * (1 - this.bias);
                                        this.z = this.z * this.bias + reading.z * (1 - this.bias);
                                }
                        };

                        customElements.define('video-view', class extends HTMLElement {
                                constructor() {
                                super();
                                const template = document.querySelector('#video-view');
                                const clone = document.importNode(template.content, true);
                                const shadowRoot = this.attachShadow({ mode: 'open' });
                                shadowRoot.appendChild(clone);
                                        this.longitude;
                                        this.latitude;
			        }

                                connectedCallback() {
                                        try {
                                        //Acceleration sensor
                                        accel_sensor = new Pedometer();
                                        accel_sensor.onchange = () => { saveSensorReading(); 
                                        }
                                        accel_sensor.onactivate = () => {
                                        }
                                        accel_sensor.start();
                                        orientation_sensor = new AbsOriSensor();
                                        orientation_sensor.onchange = () => { 
                                                this.roll = orientation_sensor.roll;
                                                this.pitch = orientation_sensor.pitch;
                                                this.yaw = orientation_sensor.yaw; 
                                                if(initialoriobtained == false) //obtain initial longitude
                                                {
                                                        let yawInitial = orientation_sensor.yaw;
                                                        longitudeInitial = -yawInitial * 180 / Math.PI;
                                                        initialoriobtained = true;
                                                }                     
                                        }
                                        orientation_sensor.onactivate = () => this.render();
                                        orientation_sensor.start();
                                        }
                                        catch(err) {
                                                console.log(err.message);
                                        }
                                        reading = setInterval(saveSensorReading, 1000/sensorfreq);     //start saving data from sensors in loop
                                        //ThreeJS scene setup below

			                this.renderer = new THREE.WebGLRenderer();
			                this.renderer.setSize(window.innerWidth, window.innerHeight);
			                document.body.appendChild(this.renderer.domElement);

			                this.scene = new THREE.Scene();

			                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1000);
			                this.camera.target = new THREE.Vector3(0, 0, 0);

			                let sphere = new THREE.SphereGeometry(100, 100, 40);
			                sphere.applyMatrix(new THREE.Matrix4().makeScale(-1, 1, 1));

                                        let texture = new THREE.VideoTexture(myVideo);
                                        texture.minFilter = THREE.LinearFilter;
                                        texture.magFilter = THREE.LinearFilter;
                                        texture.format = THREE.RGBFormat;

                                        let sphereMaterial = new THREE.MeshBasicMaterial( { map: texture, overdraw: 0.5 } );
			                let sphereMesh = new THREE.Mesh(sphere, sphereMaterial);
			                this.scene.add(sphereMesh);


                                        //render = setInterval(render, 1000/(fps+sensorfreq));
                                }
                                render() {
                                        this.longitude = -this.yaw * 180 / Math.PI;
                                        this.latitude = this.roll * 180 / Math.PI - 90;
                                        // limiting latitude from -85 to 85 (cannot point to the sky or under your feet)
                                        this.latitude = Math.max(-85, Math.min(85, this.latitude));

                                        // moving the camera according to current latitude (vertical movement) and longitude (horizontal movement)
                                        this.camera.target.x = 500 * Math.sin(THREE.Math.degToRad(90 - this.latitude)) * Math.cos(THREE.Math.degToRad(longitude));
                                        this.camera.target.y = 500 * Math.cos(THREE.Math.degToRad(90 - this.latitude));
                                        this.camera.target.z = 500 * Math.sin(THREE.Math.degToRad(90 - this.latitude)) * Math.sin(THREE.Math.degToRad(longitude));
                                        this.camera.lookAt(this.camera.target);

                                        // Render loop
                                        this.renderer.render(this.scene, this.camera);
                                        requestAnimationFrame(() => this.render());
                                }

                        });
                        function saveSensorReading()
                        {                       
                                //accel = {x:accel.x, y:accel.y, z:accel.z};
                                accelFiltered = new LowPassFilterData(accel, bias);
                                //console.log("Mags:", magnitude(prevaccel), magnitude(accelFiltered));
                                if(magnitude(prevaccel) != magnitude(accel) && Math.abs(magnitude(accelFiltered) - magnitude(prevaccel)) > 0.1)                               
                                {
                                        //console.log("Accel logged:", magnitude(accelFiltered));
                                        accelerationData.push(accelFiltered);
                                        prevaccel = accel;
                                        discardedsamples = discardedsamples - 3;
                                }
                                else
                                {
                                        discardedsamples = discardedsamples + 1;
                                }
                                //console.log(accelerationData);
                                accData2 = [];
                                accel2 = {x:null, y:null, z:null}
                                if(accelerationData.length >= amtStepValues)    //when we have enough data, decide whether the user is walking or not
                                {
                                        accelSeq = toCoordSeq(accelerationData);
                                        var as = Object.assign({}, accelSeq);
                                        peakdiff = [];
                                        valleydiff = [];
                                        stepvar = stepDetection(as);
                                        //Show data
                                        stddev_div = document.getElementById("stddev");
                                        stddev_div.innerHTML = stddevpct;
                                        //console.log(maseq);                                     
                                        if(stepvar == true)
                                        {
                                                console.log("Walking");                                        
                                        }
                                        else
                                        {
                                                console.log("Not walking");
                                        }
                                        //clear buffer
                                        for (var k in accelSeq) delete accelSeq[k];
                                        //maybe try slicing?
                                        accelerationData.splice(0);
                                        lastpeakmag = null;
                                        lastvalleymag = null;
                                        lastpeaktime = null;
                                        lastvalleytime = null;
                                        stepaverage = null;
                                        peaktimethreshold = null;
                                        valleytimethreshold = null;
                                        discardedsamples = 0;
                                        //console.log(accelerationData);
                                }
                                if(discardedsamples >= amtStepValues/3)     //device most likely stationary
                                {
                                        stepvar = 0;
                                        console.log("Stationary, not walking");
                                        discardedsamples = 0;
                                        //clear buffer
                                        for (var k in accelSeq) delete accelSeq[k];
                                        //maybe try slicing?
                                        accelerationData.splice(0);
                                        lastpeakmag = null;
                                        lastvalleymag = null;
                                        lastpeaktime = null;
                                        lastvalleytime = null;
                                        stepaverage = null;
                                        peaktimethreshold = null;
                                        valleytimethreshold = null;
                                        //console.log(accelerationData);
                                }
                        }
                        function render()
                        {
                                if(stepvar == 1)
                                {
                                        //console.log("Playing");
                                        walking_status_div = document.getElementById("walking_status");
                                        walking_status_div.innerHTML = "Walking";
                                        myVideo.play(); 
                                }
                                else
                                {
                                        //console.log("Not playing");
                                        myVideo.pause();
                                        walking_status_div = document.getElementById("walking_status");
                                        walking_status_div.innerHTML = "Not walking";
                                }
                                //check if need to rewind... On Windows, reference frame is dependent on screen orientation, so hard to get working correctly                
                                if(Math.abs(longitude - longitudeInitial) > 135 && rewinding == false)
                                {
                                        console.log("Rewind");
                                        rewinding = true;
                                }
                                else if (Math.abs(longitude - longitudeInitial) < 135 && rewinding == true)
                                {
                                        console.log("No rewind");
                                        rewinding = false;
                                }
		        }

                        function startDemo() {  //need user input to play video
                                myVideo.play();
                                myVideo.pause();
                                document.getElementById('startbutton').remove();     //hide button
                        }	
                        function rewind() {
/*                                if (rewinding)
                                {
	                                rewinding = false;
	                                clearInterval(rw);
                                }
                                else
                                {
	                                rewinding = true;
	                                //rw = setInterval(function(){ myVideo.currentTime = myVideo.currentTime - 1/fps; }, 1000/fps);
                                        //myVideo.setAttribute('src', 'https://raw.githubusercontent.com/jessenie-intel/websensor-video/master/backward2.mp4');
                                }*/
                        }		
		</script>
	</body>
</html>

