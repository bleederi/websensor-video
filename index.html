<!--
Copyright 2017 Jesse Nieminen

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<!doctype html>
<html>
	<head>
                <meta charset="UTF-8" />
                <meta name="viewport" content="width=device-width, initial-scale=0.6">
                <link rel="manifest" href="manifest.json" />
		<style>
			body{
				margin: 0;
			}
                   #startbutton {
                        background-color: red;
                        color: #FFFFFF;
                        padding: 15px 32px;
                        border-radius: 10px;
                        margin:10px
                    }
                   #rewindbutton {
                        background-color: blue;
                        color: #FFFFFF;
                        padding: 15px 32px;
                        border-radius: 10px;
                        margin:10px
                    }
		</style>
		
	</head>
        <template id="video-view">
                <style>
                :host {
                width: 100vh;
                height: 100vh;
                }
                </style>
        </template>
	<body>
                <button id="startbutton" onclick="startDemo()">Start demo</button>
                <button id="rewindbutton" onclick="rewind()">Rewind</button>
                <button onclick="play()">Play</button>
                <button id="play2" hidden>Play2</button>
                <video-view id="videoview">
                </video-view>
                <script type="text/javascript" src="script.js"></script>        <!-- Contains the step detection algorithm -->
                <script src="three.min.js"></script>

                <input id="slider_stddev" type="range" min="0.1" max="6" step="0.2" value="2">

                Standard deviation threshold: <div id="slider_stddev_amount"></div>

                <input id="slider_stepamt" type="range" min="1" max="5" step="0.5" value="2.5">

                Seconds to capture(delay): <div id="slider_stepamt_amount"></div>

                <input id="slider_bias" type="range" min="0.1" max="1" step="0.1" value="0.9">

                Filter bias: <div id="slider_bias_amount"></div>

                Walking status: <div id="walking_status"></div>

                Standard deviation pct: <div id="stddev"></div>

                <script>
		//TODO: fix rewind by using two video streams, one forward and one backward
                var myVideo = document.getElementById("video1f"); 
                var rewinding = false;
                var rw; //variable for controlling the rewind loop
                var ppr;
                var fps = 30;
                var accelerationData = [];        //sequence to store xyz accelerometer readings
                var accelSeq = {x:null, y:null, z:null};      //dict to store accelerometer reading sequences 
                var accel = {x:null, y:null, z:null};
                var accelFiltered = {x:null, y:null, z:null};
                var gravity;
                var accelNoG;
                var orientationMat = new Float64Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]);     //device orientation
                var orientationMatInitial = new Float64Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]);          //variable for storing initial orientation matrix
                var prevaccel = {x:null, y:null, z:null};
                var diff = {x:null, y:null, z:null};
                var sensorfreq = 60;
                var stepvar = null;
                var stepamt = 2;      //2.5 seems to work well for walking in place, 2 with tablet
                var amtStepValues = stepamt*sensorfreq; //setting buffer size for step analysis (how many values will be inspected) - should be about how long 2 steps will take (here stepamt seconds)
                var reading;    //variable for controlling the data reading loop
                var derseq;
                var derseq_old;
                var maseq = null;
                var maseq_old = null;
                var lastpeakmag = null;
                var lastvalleymag = null;
                var lastpeaktime = null;
                var lastvalleytime = null;
                var stepaverage = null;
                var peaktimethreshold = null;
                var valleytimethreshold = null;
                var accel_sensor = null;
                var orientation_sensor = null;
                var discardedsamples = 0;
                //In below arrays, first values for Windows tablet, second values for Nexus tablet
                var stddevthreshold = 2.9;      //0.4 good for walking in place, 2.9 with tablet
                var peakvalleyamtthreshold = [2, 6];
                var bias = 1; //bias for low-pass filtering the data, 1 seems to work good with the tablet
                var initialoriobtained = false;
                var roll = 0;
                var pitch = 0;
                var yaw = 0;
                var longitude = 0;
                var latitude = 0;
                var longitudeInitial = null;
                var anglesCurrent = [];            
                var latitude;
                var longitude;
                var videocanvasctx = null;
                var renderer = null;
                var scene = null;
                var sphere = null;
                var video = null;
                var videoF = null;
                var videoB = null;
                var videoTexture = null;
                var sphereMaterial = null;
                var sphereMesh = null;
                var nosensors = false;
                //for timekeeping
                var time = null;

                //Load two video elements, one forward and one backward
                var videoDiv = document.getElementById("videoview"); 

                var videoF = document.createElement('video');
                videoF.id = 'videof';
                //videoF.hidden = true;
                //videoF.autoplay = true;
                videoF.src    = 'https://raw.githubusercontent.com/jessenie-intel/websensor-video/master/forward2.mp4';
                //videoF.src = window.URL.createObjectURL('https://raw.githubusercontent.com/jessenie-intel/websensor-video/master/forward2.mp4');
                //videoF.srcObject = 'https://raw.githubusercontent.com/jessenie-intel/websensor-video/master/forward2.mp4';
                videoF.crossOrigin = 'anonymous';
                //videoF.load();
                //document.body.insertBefore(videoF, videoDiv);
                var videoFdiv = document.getElementById("videof");

                var videoB = document.createElement('video');
                //videoB.id = 'videob';
                //videoB.hidden = true;
                //videoB.autoplay = true;
                videoB.src    = 'https://raw.githubusercontent.com/jessenie-intel/websensor-video/master/backward2.mp4';
                //videoB.src = window.URL.createObjectURL('https://raw.githubusercontent.com/jessenie-intel/websensor-video/master/backward2.mp4');
                videoB.crossOrigin = 'anonymous';
                //document.body.insertBefore(videoB, videoFdiv);
                //videoB.load();

                renderer = new THREE.WebGLRenderer();
                renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(renderer.domElement);

                scene = new THREE.Scene();

                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1000);
                this.camera.target = new THREE.Vector3(0, 0, 0);

                sphere = new THREE.SphereGeometry(100, 100, 40);
                sphere.applyMatrix(new THREE.Matrix4().makeScale(-1, 1, 1));
                //document.getElementById('videof').load();
                //document.getElementById('videob').load();
                video = videoF; //start with the forward video
                video.load();
                videoTexture = new THREE.Texture(video);
                videoTexture.minFilter = THREE.LinearFilter;
                videoTexture.magFilter = THREE.LinearFilter;
                videoTexture.format = THREE.RGBFormat;

                sphereMaterial = new THREE.MeshBasicMaterial( { map: videoTexture, overdraw: 0.5 } );
                sphereMesh = new THREE.Mesh(sphere, sphereMaterial);
                //sphereMesh.geometry.dynamic = true;
                scene.add(sphereMesh);

                function render() {
                        if( video.readyState === video.HAVE_ENOUGH_DATA ){
                                videoTexture.needsUpdate = true;
                        }
                        if(nosensors)   //for testing
                        {
                                longitude = 0;
                                latitude = 0;
                        }
                        else
                        {
                                longitude = -yaw * 180 / Math.PI;
                                latitude = roll * 180 / Math.PI - 90;

                        }
                        // moving the camera according to current latitude (vertical movement) and longitude (horizontal movement)
                        this.camera.target.x = 500 * Math.sin(THREE.Math.degToRad(90 - latitude)) * Math.cos(THREE.Math.degToRad(longitude));
                        this.camera.target.y = 500 * Math.cos(THREE.Math.degToRad(90 - latitude));
                        this.camera.target.z = 500 * Math.sin(THREE.Math.degToRad(90 - latitude)) * Math.sin(THREE.Math.degToRad(longitude));
                        this.camera.lookAt(this.camera.target);

                        // Render loop
                        this.renderer.render(this.scene, this.camera);
                        requestAnimationFrame(() => this.render());
                }

                function playPauseRewind()
                {
                        if(stepvar === true)
                        {
                                //console.log("Playing");
                                let walking_status_div = document.getElementById("walking_status");
                                walking_status_div.innerHTML = "Walking";
                                const playPromise = video.play();
                                if (playPromise !== null){
                                    playPromise.catch(() => { video.play(); })
                                }
                        }
                        else if (stepvar === false)
                        {
                                //console.log("Not playing");
                                if(!video.paused)
                                {
                                        video.pause();
                                }
                                let walking_status_div = document.getElementById("walking_status");
                                walking_status_div.innerHTML = "Not walking";
                        }
                        //rewind
                        if((Math.abs(longitude - longitudeInitial) > 175 && rewinding === false) || (Math.abs(longitude - longitudeInitial) < 5 && rewinding === true))
                        {
                                rewind();
                        }
                }

                        function play()
                        {
                                if(!rewinding)
                                {
                                        if(videoF.paused)
                                        {
                                        var playPromiseF = videoF.play();

                                        // In browsers that don’t yet support this functionality,
                                        // playPromise won’t be defined.
                                        if (playPromiseF !== undefined) {
                                          playPromiseF.then(function() {
                                            // Automatic playback started!
                                                console.log("Playing");
                                          }).catch(function(error) {
                                                console.log("Promise failed", error.name);
                                            // Automatic playback failed.
                                            // Show a UI element to let the user manually start playback.
                                          var playButton = document.querySelector('#play2');
                                          // The user interaction requirement is met if
                                          // playback is triggered via a click event.
                                          playButton.addEventListener('click', startPlaybackF);
                                          playButton.hidden = false;
                                          });
                                        }   }
                                        else
                                        {
                                                videoF.pause();                                
                                        }
                                }    
                                else if(rewinding)
                                {
                                        if(videoB.paused)
                                        {
                                        var playPromiseB = videoB.play();

                                        // In browsers that don’t yet support this functionality,
                                        // playPromise won’t be defined.
                                        if (playPromiseB !== undefined) {
                                          playPromiseB.then(function() {
                                            // Automatic playback started!
                                                console.log("Playing");
                                          }).catch(function(error) {
                                                console.log("Promise failed", error.name);
                                            // Automatic playback failed.
                                            // Show a UI element to let the user manually start playback.
                                          var playButton = document.querySelector('#play2');
                                          // The user interaction requirement is met if
                                          // playback is triggered via a click event.
                                          playButton.addEventListener('click', startPlaybackB);
                                          playButton.hidden = false;
                                          });
                                        }   }
                                        else
                                        {
                                                videoB.pause();                                
                                        }
                                }               
                        }

                //Sliders
                var slider_stddev = document.getElementById('slider_stddev'),
                slider_stddev_div = document.getElementById("slider_stddev_amount");
                slider_stddev.onchange = () => {
                        stddevthreshold = slider_stddev.value;
                        slider_stddev_div.innerHTML = stddevthreshold;
                        console.log("Std dev threshold:", stddevthreshold);
                }
                var slider_stepamt = document.getElementById('slider_stepamt'),
                slider_stepamt_div = document.getElementById("slider_stepamt_amount");
                slider_stepamt.onchange = () => {
                        stepamt = slider_stepamt.value;
                        amtStepValues = stepamt*sensorfreq;     //recalculate
                        slider_stepamt_div.innerHTML = stepamt;
                        console.log("Step amount:", stepamt);
                }
                var slider_bias = document.getElementById('slider_bias'),
                slider_bias_div = document.getElementById("slider_bias_amount");
                slider_bias.onchange = () => {
                        bias = slider_bias.value;
                        slider_bias_div.innerHTML = bias;
                        console.log("Filter bias:", bias);
                }
                //myVideo.load();
                //myVideo.pause();
                        class Pedometer {
                                constructor() {
                                const sensor = new Accelerometer({ frequency: sensorfreq });
                                gravity =  new LowPassFilterData(sensor, 0.8);
                                sensor.onchange = () => {
                                        accel = {'x':sensor.x, 'y':sensor.y, 'z':sensor.z};
                                        if (this.onchange) this.onchange();
                                };
                                sensor.onactivate = () => {
                                        if (this.onactivate) this.onactivate();
                                }
                                const start = () => sensor.start();
                                Object.assign(this, { start });
                                }
                        }
                        class AbsOriSensor {
                                constructor() {
                                const sensor = new AbsoluteOrientationSensor({ frequency: sensorfreq });
                                const mat4 = new Float32Array(16);
                                const euler = new Float32Array(3);
                                sensor.onchange = () => {
                                        sensor.populateMatrix(mat4);
                                        let angles = toEulerianAngle(sensor.quaternion, euler);
                                        //console.log("ANGLES:", angles);
                                        this.roll = euler[0];
                                        this.pitch = euler[1];
                                        this.yaw = euler[2];
                                        if (this.onchange) this.onchange();
                                };
                                sensor.onactivate = () => {
                                        if (this.onactivate) this.onactivate();
                                }
                                const start = () => sensor.start();
                                Object.assign(this, { start });
                                }
                        }
                        class LowPassFilterData {       //https://w3c.github.io/motion-sensors/#pass-filters
                          constructor(reading, bias) {
                            Object.assign(this, { x: reading.x, y: reading.y, z: reading.z });
                            this.bias = bias;
                          }
                                update(reading) {
                                        this.x = this.x * this.bias + reading.x * (1 - this.bias);
                                        this.y = this.y * this.bias + reading.y * (1 - this.bias);
                                        this.z = this.z * this.bias + reading.z * (1 - this.bias);
                                }
                        };

                        customElements.define('video-view', class extends HTMLElement {
                                constructor() {
                                super();
			        }

                                connectedCallback() {
                                        try {
                                        //Acceleration sensor
                                        accel_sensor = new Pedometer();
                                        accel_sensor.onchange = () => {
                                        }
                                        accel_sensor.onactivate = () => {
                                        }
                                        accel_sensor.start();
                                        orientation_sensor = new AbsOriSensor();
                                        orientation_sensor.onchange = () => { 
                                                roll = orientation_sensor.roll;
                                                pitch = orientation_sensor.pitch;
                                                yaw = orientation_sensor.yaw; 
                                                if(initialoriobtained == false) //obtain initial longitude
                                                {
                                                        let yawInitial = orientation_sensor.yaw;
                                                        longitudeInitial = -yawInitial * 180 / Math.PI;
                                                        initialoriobtained = true;
                                                }                     
                                        }
                                        orientation_sensor.onactivate = () => {
                                        }
                                        orientation_sensor.start();
                                        }
                                        catch(err) {
                                                console.log(err.message);
                                                nosensors = true;
                                        }
                                }

                        });
                        function saveSensorReading()
                        {                       
                                accel = {x:accel.x, y:accel.y, z:accel.z};
                                accelFiltered = new LowPassFilterData(accel, bias);
                                //accelNoG = {x:accel.x - gravity.x, y:accel.y - gravity.y, z:accel.z - gravity.z};
                                //console.log("Mags:", magnitude(prevaccel), magnitude(accelFiltered))
                                if(magnitude(prevaccel) != magnitude(accel) && Math.abs(magnitude(accelFiltered) - magnitude(prevaccel)) > 0.1)                               
                                {
                                        //console.log("Accel logged:", magnitude(accelFiltered));
                                        accelerationData.push(accelFiltered);
                                        prevaccel = accel;
                                        discardedsamples = discardedsamples - 3;
                                }
                                else
                                {
                                        discardedsamples = discardedsamples + 1;
                                }
                                //console.log(accelerationData);
                                accData2 = [];
                                accel2 = {x:null, y:null, z:null}
                                if(accelerationData.length >= amtStepValues)    //when we have enough data, decide whether the user is walking or not
                                {
                                        accelSeq = toCoordSeq(accelerationData);
                                        var as = Object.assign({}, accelSeq);
                                        peakdiff = [];
                                        valleydiff = [];
                                        stepvar = stepDetection(as);
                                        //Show data
                                        stddev_div = document.getElementById("stddev");
                                        stddev_div.innerHTML = stddevpct;
                                        //console.log(maseq);                                     
                                        if(stepvar === true)
                                        {
                                                //console.log("Walking");                                        
                                        }
                                        else
                                        {
                                                //console.log("Not walking");
                                        }
                                        //clear buffer
                                        for (var k in accelSeq) delete accelSeq[k];
                                        //maybe try slicing?
                                        accelerationData.splice(0);
                                        lastpeakmag = null;
                                        lastvalleymag = null;
                                        lastpeaktime = null;
                                        lastvalleytime = null;
                                        stepaverage = null;
                                        peaktimethreshold = null;
                                        valleytimethreshold = null;
                                        discardedsamples = 0;
                                        //console.log(accelerationData);
                                }
                                if(discardedsamples >= amtStepValues/3)     //device most likely stationary
                                {
                                        stepvar = 0;
                                        //console.log("Stationary, not walking");
                                        discardedsamples = 0;
                                        //clear buffer
                                        for (var k in accelSeq) delete accelSeq[k];
                                        //maybe try slicing?
                                        accelerationData.splice(0);
                                        lastpeakmag = null;
                                        lastvalleymag = null;
                                        lastpeaktime = null;
                                        lastvalleytime = null;
                                        stepaverage = null;
                                        peaktimethreshold = null;
                                        valleytimethreshold = null;
                                        //console.log(accelerationData);
                                }
                        }

function startPlaybackF() {
  return videoF.play();
}
function startPlaybackB() {
  return videoB.play();
}

                        function startDemo() {  //need user input to play video
                                render();
                                var playPromiseF = videoF.play();

                                // In browsers that don’t yet support this functionality,
                                // playPromise won’t be defined.
                                if (playPromiseF !== undefined) {
                                  playPromiseF.then(function() {
                                    // Automatic playback started!
                                        console.log("Playing");
                                  }).catch(function(error) {
                                        console.log("Promise failed", error.name);
                                    // Automatic playback failed.
                                    // Show a UI element to let the user manually start playback.
                                  var playButton = document.querySelector('#play2');
                                  // The user interaction requirement is met if
                                  // playback is triggered via a click event.
                                  playButton.addEventListener('click', startPlaybackF);
                                  playButton.hidden = false;
                                  });
                                var playPromiseB = videoB.play();

                                // In browsers that don’t yet support this functionality,
                                // playPromise won’t be defined.
                                if (playPromiseB !== undefined) {
                                  playPromiseB.then(function() {
                                    // Automatic playback started!
                                        console.log("Playing");
                                  }).catch(function(error) {
                                        console.log("Promise failed", error.name);
                                    // Automatic playback failed.
                                    // Show a UI element to let the user manually start playback.
                                  var playButton = document.querySelector('#play2');
                                  // The user interaction requirement is met if
                                  // playback is triggered via a click event.
                                  playButton.addEventListener('click', startPlaybackB);
                                  playButton.hidden = false;
                                  });
                                }}
                                /*const playPromise = video.play();
                                if (playPromise !== null){
                                    playPromise.catch(() => { video.play(); })
                                }
                                if(!myVideo.paused)
                                {
                                        myVideo.pause();
                                }*/
                                videoF.pause();
                                videoB.pause();
                                document.getElementById('startbutton').remove();     //hide button
                                if(!nosensors)
                                {
                                        reading = setInterval(saveSensorReading, 1000/sensorfreq);     //start saving data from sensors in loop
                                        ppr = setInterval(playPauseRewind, 1000/(fps+sensorfreq));
                                }
                        }	

                 /*       function rewind() {
                               if(rewinding === false)
                                {
                                        console.log("Loading backward video");
                                        //const playPromise = myVideo.play();
                                        //if (playPromise !== null){
                                        //    playPromise.catch(() => { myVideo.play(); })
                                        //}
                                        //if(!myVideo.paused)
                                        //{
                                        //        myVideo.pause();
                                        //}
                                        video = videoB;
                                        videoTexture = new THREE.Texture(video);
                                        videoTexture.minFilter = THREE.LinearFilter;
                                        videoTexture.magFilter = THREE.LinearFilter;
                                        videoTexture.format = THREE.RGBFormat;
                                        videoTexture.needsUpdate = true;
			                scene.remove(sphereMesh);
                                        sphereMaterial = new THREE.MeshBasicMaterial( { map: videoTexture, overdraw: 0.5 } );
			                sphereMesh = new THREE.Mesh(this.sphere, sphereMaterial);
                                        //sphereMesh.geometry.dynamic = true;
                                        sphereMaterial.needsUpdate = true;
			                scene.add(sphereMesh);
                                        rewinding = true;
                                        return 0;
                                        }
                                //console.log("No rewind");
                                else
                                {
                                        console.log("Loading forward video");
                                        video = videoF;
                                        videoTexture = new THREE.Texture(video);
                                        videoTexture.minFilter = THREE.LinearFilter;
                                        videoTexture.magFilter = THREE.LinearFilter;
                                        videoTexture.format = THREE.RGBFormat;
                                        videoTexture.needsUpdate = true;
			                scene.remove(sphereMesh);
                                        sphereMaterial = new THREE.MeshBasicMaterial( { map: videoTexture, overdraw: 0.5 } );
			                sphereMesh = new THREE.Mesh(this.sphere, sphereMaterial);
                                        //sphereMesh.geometry.dynamic = true;
                                        sphereMaterial.needsUpdate = true;
			                scene.add(sphereMesh);
                                        rewinding = false;
                                        return 0;                                             
                                }
                        }
	*/		
                        function rewind() {
                               if(rewinding === false)
                                {
                                        console.log("Loading backward video");
                                        time = videoF.currentTime;
                                        videoF.pause();
                                        video = videoB;
                                        //videoB.load();
                                        videoB.currentTime = videoB.duration - time;
                                        //console.log(videoB.currentTime);
                                        videoTexture = new THREE.Texture(videoB);
                                        videoTexture.minFilter = THREE.LinearFilter;
                                        videoTexture.magFilter = THREE.LinearFilter;
                                        videoTexture.format = THREE.RGBFormat;
                                        videoTexture.needsUpdate = true;
			                scene.remove(sphereMesh);
                                        sphereMaterial = new THREE.MeshBasicMaterial( { map: videoTexture, overdraw: 0.5 } );
			                sphereMesh = new THREE.Mesh(this.sphere, sphereMaterial);
                                        //sphereMesh.geometry.dynamic = true;
                                        sphereMaterial.needsUpdate = true;
			                scene.add(sphereMesh);
                                        //video.play();
                                        rewinding = true;
                                        return 0;
                                        }
                                //console.log("No rewind");
                                else if (rewinding === true)
                                {
                                        console.log("Loading forward video");
                                        time = videoB.currentTime;
                                        videoB.pause();
                                        video = videoF;
                                        //videoF.load();
                                        videoF.currentTime = videoF.duration - time;
                                        //console.log(videoF.currentTime);
                                        videoTexture = new THREE.Texture(videoF);
                                        videoTexture.minFilter = THREE.LinearFilter;
                                        videoTexture.magFilter = THREE.LinearFilter;
                                        videoTexture.format = THREE.RGBFormat;
                                        videoTexture.needsUpdate = true;
			                scene.remove(sphereMesh);
                                        sphereMaterial = new THREE.MeshBasicMaterial( { map: videoTexture, overdraw: 0.5 } );
			                sphereMesh = new THREE.Mesh(this.sphere, sphereMaterial);
                                        //sphereMesh.geometry.dynamic = true;
                                        sphereMaterial.needsUpdate = true;
			                scene.add(sphereMesh);
                                        //video.play();
                                        rewinding = false;
                                        return 0;                                             
                                }
                        }
		</script>
	</body>
</html>



