<!--
Copyright 2017 Jesse Nieminen

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<!doctype html>
<html>
	<head>
                <meta charset="UTF-8" />
                <meta name="viewport" content="width=device-width, initial-scale=0.6">
                <link rel="manifest" href="manifest.json" />
		<style>
			body{
				margin: 0;
			}
		</style>
		
	</head>
        <template id="video-view">
                <style>
                :host {
                width: 100vh;
                height: 100vh;
                }
                </style>
        </template>
	<body>
                <button onclick="playPause()">Play/Pause</button>
                <button onclick="rewind()">Rewind</button>
                <video-view>
                        <video id="video1" width="800" height="600" autoplay>
                        <source src="video.mp4" type="video/mp4">
                        Your browser does not support the video tag.
                        </video>
                </video-view>
                <script type="text/javascript" src="script.js"></script>        <!-- Contains the step detection algorithm -->

                <input id="slider_stddev" type="range" min="0.1" max="4" step="0.1" value="0.4">

                Standard deviation threshold: <div id="slider_stddev_amount"></div>

                <input id="slider_stepamt" type="range" min="1" max="5" step="0.5" value="2.5">

                Seconds to capture(delay): <div id="slider_stepamt_amount"></div>

                <input id="slider_bias" type="range" min="0.1" max="1" step="0.1" value="0.9">

                Filter bias: <div id="slider_bias_amount"></div>

                Walking status: <div id="walking_status"></div>

                <script>
		//TODO: fix rewind by using two video streams, one forward and one backward
                var myVideo = document.getElementById("video1"); 
                var rewinding = false;
                var rw; //variable for controlling the rewind loop
                var fps = 30;
                var accelerationData = [];        //sequence to store xyz accelerometer readings
                var accelSeq = {x:null, y:null, z:null};      //dict to store accelerometer reading sequences 
                var accel = {x:null, y:null, z:null};
                var accelFiltered = {x:null, y:null, z:null};
                var gravity;
                var accelNoG;
                var orientationMat = new Float64Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]);     //device orientation
                var orientationMatInitial = new Float64Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]);          //variable for storing initial orientation matrix
                var prevaccel = {x:null, y:null, z:null};
                var diff = {x:null, y:null, z:null};
                var sensorfreq = 60;
                var stepvar = null;
                var stepamt = 2;      //2.5 seems to work well for walking in place
                var amtStepValues = stepamt*sensorfreq; //setting buffer size for step analysis (how many values will be inspected) - should be about how long 2 steps will take (here stepamt seconds)
                var reading;    //variable for controlling the data reading loop
                var derseq;
                var derseq_old;
                var maseq = null;
                var maseq_old = null;
                var lastpeakmag = null;
                var lastvalleymag = null;
                var lastpeaktime = null;
                var lastvalleytime = null;
                var stepaverage = null;
                var peaktimethreshold = null;
                var valleytimethreshold = null;
                var accel_sensor = null;
                var orientation_sensor = null;
                var discardedsamples = 0;
                //In below arrays, first values for Windows tablet, second values for Nexus tablet
                var stddevthreshold = [0.3, 1.4];      //0.4 good for walking in place
                var peakvalleyamtthreshold = [2, 4];
                var bias = 0.9; //bias for low-pass filtering the data
                var initialoriobtained = false;
                var roll = 0;
                var pitch = 0;
                var yaw = 0;
                var yawInitial = 0;
                var anglesCurrent = [];            
                var latitude;
                var longitude;

                //Sliders
                var slider_stddev = document.getElementById('slider_stddev'),
                slider_stddev_div = document.getElementById("slider_stddev_amount");
                slider_stddev.onchange = () => {
                        stddevthreshold = slider_stddev.value;
                        slider_stddev_div.innerHTML = stddevthreshold;
                        console.log("Std dev threshold:", stddevthreshold);
                }
                var slider_stepamt = document.getElementById('slider_stepamt'),
                slider_stepamt_div = document.getElementById("slider_stepamt_amount");
                slider_stepamt.onchange = () => {
                        stepamt = slider_stepamt.value;
                        amtStepValues = stepamt*sensorfreq;     //recalculate
                        slider_stepamt_div.innerHTML = stepamt;
                        console.log("Step amount:", stepamt);
                }
                var slider_bias = document.getElementById('slider_bias'),
                slider_bias_div = document.getElementById("slider_bias_amount");
                slider_bias.onchange = () => {
                        bias = slider_bias.value;
                        slider_bias_div.innerHTML = bias;
                        console.log("Filter bias:", bias);
                }
                myVideo.pause();
                        class Pedometer {
                                constructor() {
                                const sensor = new Accelerometer({ frequency: sensorfreq });
                                gravity =  new LowPassFilterData(sensor, 0.8);
                                sensor.onchange = () => {
                                        accel = {'x':sensor.x, 'y':sensor.y, 'z':sensor.z};
                                        if (this.onchange) this.onchange();
                                };
                                sensor.onactivate = () => {
                                        if (this.onactivate) this.onactivate();
                                }
                                const start = () => sensor.start();
                                Object.assign(this, { start });
                                }
                        }
                        class AbsOriSensor {
                                constructor() {
                                const sensor = new AbsoluteOrientationSensor({ frequency: sensorfreq });
                                const mat4 = new Float32Array(16);
                                const euler = new Float32Array(3);
                                sensor.onchange = () => {
                                        sensor.populateMatrix(mat4);
                                        let angles = toEulerianAngle(sensor.quaternion, euler);
                                        //console.log("ANGLES:", angles);
                                        this.roll = euler[0];
                                        this.pitch = euler[1];
                                        this.yaw = euler[2];
                                        if (this.onchange) this.onchange();
                                };
                                sensor.onactivate = () => {
                                        if (this.onactivate) this.onactivate();
                                }
                                const start = () => sensor.start();
                                Object.assign(this, { start });
                                }
                        }
                        class LowPassFilterData {       //https://w3c.github.io/motion-sensors/#pass-filters
                          constructor(reading, bias) {
                            Object.assign(this, { x: reading.x, y: reading.y, z: reading.z });
                            this.bias = bias;
                          }
                                update(reading) {
                                        this.x = this.x * this.bias + reading.x * (1 - this.bias);
                                        this.y = this.y * this.bias + reading.y * (1 - this.bias);
                                        this.z = this.z * this.bias + reading.z * (1 - this.bias);
                                }
                        };
                        class KalmanFilter {    //Kalman filter implementation from websensor-compass
                          constructor() {
                            this.Q_angle = 0.01;
                            this.Q_gyro = 0.0003;
                            this.R_angle = 0.01;

                            this.reset();
                          }

                          reset() {
                            this.angle = 0.0;
                            this.bias = 0;

                            this.P00 = 0;
                            this.P01 = 0;
                            this.P10 = 0;
                            this.P11 = 0;
                          }

                          filter(accAngle, gyroRate, dt) {
                            this.angle += dt * (gyroRate - this.bias);

                            this.P00 += -dt * (this.P10 + this.P01) + this.Q_angle * dt;
                            this.P01 += -dt * this.P11;
                            this.P10 += -dt * this.P11;
                            this.P11 += + this.Q_gyro * dt;

                            let axis = accAngle - this.angle;
                            let S = this.P00 + this.R_angle;
                            let K0 = this.P00 / S;
                            let K1 = this.P10 / S;

                            this.angle += K0 * axis;
                            this.bias  += K1 * axis;

                            this.P00 -= K0 * this.P00;
                            this.P01 -= K0 * this.P01;
                            this.P10 -= K1 * this.P00;
                            this.P11 -= K1 * this.P01;

                            return this.angle;
                          }
                        };
/*      How to use:  
      // Kalman filter
          this.alpha = this.kalmanZ.filter(zAccel, zGyro, dt);
          this.beta = this.kalmanX.filter(xAccel, xGyro, dt);
          this.gamma = this.kalmanY.filter(yAccel, yGyro, dt);
*/

                        customElements.define('video-view', class extends HTMLElement {
                                constructor() {
                                super();
			        }

                                connectedCallback() {
                                        //Acceleration sensor
                                        accel_sensor = new Pedometer();
                                        accel_sensor.onchange = () => { saveSensorReading(); 
                                        }
                                        accel_sensor.onactivate = () => {
                                        }
                                        accel_sensor.start();
                                        orientation_sensor = new AbsOriSensor();
                                        orientation_sensor.onchange = () => { 
                                                roll = orientation_sensor.roll;
                                                pitch = orientation_sensor.pitch;
                                                yaw = orientation_sensor.yaw; 
                                                if(initialoriobtained == false)
                                                {
                                                        yawInitial = orientation_sensor.yaw;
                                                        initialoriobtained = true;
                                                }                     
                                        }
                                        orientation_sensor.onactivate = () => {
                                        }
                                        orientation_sensor.start();
                                        reading = setInterval(saveSensorReading, 1000/sensorfreq);     //start saving data from sensors in loop
                                        render = setInterval(render, 1000/(fps+sensorfreq));
                                }
                        });
                        function saveSensorReading()
                        {                       
                                accel = {x:accel.x, y:accel.y, z:accel.z};
                                accelFiltered = new LowPassFilterData(accel, bias);
                                //accelNoG = {x:accel.x - gravity.x, y:accel.y - gravity.y, z:accel.z - gravity.z};
                                //console.log("Mags:", magnitude(prevaccel), magnitude(accelFiltered))
                                if(magnitude(prevaccel) != magnitude(accel) && Math.abs(magnitude(accelFiltered) - magnitude(prevaccel)) < 0.08)                               
                                {
                                        accelerationData.push(accelFiltered);
                                        prevaccel = accel;
                                        discardedsamples = discardedsamples - 3;
                                }
                                else
                                {
                                        discardedsamples = discardedsamples + 1;
                                }
                                //console.log(accelerationData);
                                accData2 = [];
                                accel2 = {x:null, y:null, z:null}
                                if(accelerationData.length >= amtStepValues)    //when we have enough data, decide whether the user is walking or not
                                {
                                        accelSeq = toCoordSeq(accelerationData);
                                        var as = Object.assign({}, accelSeq);
                                        peakdiff = [];
                                        valleydiff = [];
                                        //console.log(accelSeq);
                                        //let length = accelSeq['x'].length;
                                        //maseq_old = maseq;
                                        //let stepvar2 = stepDetection(slice(accelSeq, length-amtStepValues, length));
                                        stepvar = stepDetection(as);
                                        //console.log(maseq);                                     
                                        if(stepvar == true)
                                        {
                                                console.log("Walking");                                        
                                        }
                                        else
                                        {
                                                console.log("Not walking");
                                        }
/*
                                        corr = {'x': pcorr(maseq['x'], maseq_old['x']), 'y': pcorr(maseq['y'], maseq_old['y']), 'z':pcorr(maseq['z'], maseq_old['z'])};
                                        //console.log(corr);
                                        //console.log(magnitude(corr));
                                        if(magnitude(corr) <= 1.7 && magnitude(corr) >= 0.5 && corr['y'] >= 0)
                                        {
                                                stepvar = 1;
                                        }
                                        else
                                        {
                                                stepvar = 0;
                                        }
*/
                                        //clear buffer
                                        for (var k in accelSeq) delete accelSeq[k];
                                        //maybe try slicing?
                                        accelerationData.splice(0);
                                        lastpeakmag = null;
                                        lastvalleymag = null;
                                        lastpeaktime = null;
                                        lastvalleytime = null;
                                        stepaverage = null;
                                        peaktimethreshold = null;
                                        valleytimethreshold = null;
                                        discardedsamples = 0;
                                        //console.log(accelerationData);
                                }
                                if(discardedsamples >= amtStepValues/3)     //device most likely stationary
                                {
                                        stepvar = 0;
                                        console.log("Stationary, not walking");
                                        discardedsamples = 0;
                                }
                        }
                        function render()
                        {
                                //console.log(this.roll, this.yaw, this.pitch);
                                longitude = -this.yaw * 180 / Math.PI;
                                let longitudeInitial = -this.yawInitial * 180 / Math.PI;
                                latitude = this.pitch * 180 / Math.PI - 90;
                                //console.log(longitude, longitudeInitial);
                                if(stepvar == 1)
                                {
                                        //console.log("Playing");
                                        walking_status_div = document.getElementById("walking_status");
                                        walking_status_div.innerHTML = "Walking";
                                        //myVideo.play(); 
                                }
                                else
                                {
                                        //console.log("Not playing");
                                        //myVideo.pause();
                                        walking_status_div = document.getElementById("walking_status");
                                        walking_status_div.innerHTML = "Not walking";
                                }
                                //check if need to rewind... On Windows, reference frame is dependent on screen orientation, so hard to get working correctly                  
                                if(Math.abs(longitude - longitudeInitial) > 90)
                                {
                                        //console.log("Rewind");
                                }
		        }

                        function playPause() {
                        if (myVideo.paused)
                                myVideo.play(); 
                        else 
                                myVideo.pause(); 
                        } 	

                        function rewind() {
                                if (rewinding)
                                {
	                                rewinding = false;
	                                clearInterval(rw);
                                }
                                else
                                {
	                                rewinding = true;
	                                rw = setInterval(function(){ myVideo.currentTime = myVideo.currentTime - 1/fps; }, 1000/fps);
                                        //myVideo.setAttribute('src', 'video_backwards.mp4');
                                }
                        }			
		</script>
	</body>
</html>

